#!/usr/bin/env sh
exec guile -e main -s "$0" "$@"
!#

(use-modules
 (ice-9 regex)
 (ice-9 rdelim)
 (ice-9 popen)
 (ice-9 match)
 (ice-9 ftw)
 (ice-9 pretty-print)
 (ice-9 poe)
 (ice-9 getopt-long)
 (web uri)
 (srfi srfi-1))

;;
;; State
;;

(define jaro/assocs '())
(define jaro/named-assocs (make-hash-table))
(define jaro/cold-run? #t)

;;
;; Extensions
;;

;; Source for -> and ->> macros:
;; https://github.com/joshwalters/guile-pipe

(define-syntax ->
  (syntax-rules ()
                ((_) #f)
                ((_ x) x)
                ((_ x (f . (f-rest ...))) (f x f-rest ...))
                ((_ x f) (f x))
                ((_ x (f . (f-rest ...)) rest ...) (-> (f x f-rest ...) rest ...))
                ((_ x f rest ...) (-> (f x) rest ...))))

(define-syntax ->>
  (syntax-rules ()
                ((_) #f)
                ((_ x) x)
                ((_ x (f ...)) (f ... x))
                ((_ x f) `(f x))
                ((_ x (f ...) rest ...) (->> (f ... x) rest ...))
                ((_ x f rest ...) (->> (f x) rest ...))))

(define-syntax if-let
  (syntax-rules ()
    ((if-let ((var value) ...)
             consequent ...)
     (let ((var value) ...)
       (if (and var ...)
           consequent ...)))))

(define-syntax when-let
  (syntax-rules ()
    ((when-let (binding)
               body ...)
     (if-let (binding)
             (begin body ...)))))

;;
;; Utils
;;

(define specified? (compose not unspecified?))

(define (read-sys-out cmd)
  (let* ((port (cond
                ((string? cmd) (open-input-pipe cmd))
                ((list? cmd) (apply open-pipe* (cons OPEN_READ cmd)))))
         (out (read-string port)))
    (cond
     ((equal? 0 (close-pipe port)) (string-split (string-trim-both out) #\newline))
     (#t #f))))

;; https://github.com/alezost/guile-config/blob/master/modules/al/plists.scm
(define (plist-get plist property)
  "Return a value of PROPERTY from PLIST.
Return #f if PROPERTY does not exist."
  (match plist
    ((prop val rest ...)
     (if (eq? prop property)
         val
         (plist-get rest property)))
    (_ #f)))

;;
;; Mimetype
;;

(define (mimetype-by command)
  "Extract the mimetype from the output of the COMMAND."
  (let ((mime (read-sys-out command)))
    (and mime (car mime))))

(define (mimetype-of-uri URI)
  "Get the mimetype of given URI."
  (let ((uri (string->uri URI)))
    (and
     uri
     (->>
      (uri-scheme uri)
      (symbol->string)
      (string-append "x-scheme-handler/")))))

(define (mimetype-of-file file)
  "Get the mimetype of FILE using `mimetype' binary."
  (let ((mimetype
         (or
          (mimetype-by `("mimetype" "--brief" "--dereference" ,file))
          (mimetype-by `("file" "--brief" "--dereference" "--mime-type" ,file)))))
    (and (not (string-null? mimetype)) mimetype)))

(define mimetype
  (pure-funcq
   (λ (path)
     "Get mimetype of given PATH."
     (or
      (mimetype-of-uri path)
      (mimetype-of-file path)))))

;;
;; Pattern
;;

(define (pattern-matches? pattern input)
  "Check if PATTERN matches with the INPUT."
  (cond
   ((regexp? pattern) (regexp-exec pattern input))
   ((list? pattern) (any identity (map (λ (it) (pattern-matches? it input)) pattern)))
   (else #f)))

(define (compile-pattern pattern)
  "Compile given PATTERN into regexp or list of regexpes."
  (cond
   ((string? pattern) (make-regexp pattern))
   ((regexp? pattern) pattern)
   ((list? pattern) (map compile-pattern pattern))))

(define running-environment
  (let ((current-environment #f))
    (λ ()
      "Return the current environment.
It can be either 'gui, 'term, 'tmux, 'screen."
      (unless current-environment
        (set!
         current-environment
         (cond
          ((isatty? (current-output-port)) 'term)
          ((getenv "TMUX") 'tmux)
          ((getenv "STY") 'screen)
          (else 'gui))))
      current-environment)))

(define (assoc->runner assoc)
  "Get the running strategy for given ASSOC based on the environment."
  (let ((default (plist-get assoc #:program)))
    (case (running-environment)
      ((tmux) (or (plist-get assoc #:tmux) default))
      ((screen) (or (plist-get assoc #:screen) default))
      ((term) (or (plist-get assoc #:term) default))
      (else default))))

;;
;; Running programs
;;

;; TODO: maybe extend this, so that user can define what happens on
;; each exit code.  like #:exit-0 "this" #:exit-555 "that"
(define (map-exit-code code)
  (case code
    ((0) #t)
    (else #f)))

(define (program? it)
  "Return if IT is a runnable thing or not."
  (or (string? it)
      (procedure? it)
      (and (list? it) (not (null-list? it)))
      (and (symbol? it) (hashq-get-handle jaro/named-assocs it))))

(define (jaro/system program)
  (if jaro/cold-run?
      (let ((program-to-run (if (list? program) (string-join program " ") program)))
        (display "(jaro/system) ")
        (display program-to-run)
        (newline)
        program-to-run)
       (map-exit-code
        (cond
         ((string? program) (system program))
         ((list? program) (apply system* program))))))

;; TODO add coldrun
(define (run-program program pattern input)
  (cond
   ((procedure? program)
    (program
     input
     (mimetype input)
     (get-matches program pattern input)))
   ((or (list? program) (string? program))
    (jaro/system (format-program program pattern input)))
   (else
    (->>
     (hashq-get-handle jaro/named-assocs program)
     (cdr)
     (assoc->runner)
     ((λ (it) (run-program it pattern input)))))))

(define (run-assoc assoc alternatives input)
  (let* ((pattern (plist-get assoc #:pattern))
         (success? (run-program (assoc->runner assoc) pattern input))
         (on-success (plist-get assoc #:on-success))
         (on-error (plist-get assoc #:on-error)))
      (cond
       ((and success? on-success)
        (run-program pattern on-success input))
       (success?
        success?)
       ((eq? on-error 'continue)
        (if (null? alternatives)
            'jaro/no-matches
            (run-assoc (car alternatives) (cdr alternatives) input)))
       ((eq? on-error #f)
        'jaro/non-zero-without-on-error)
       ((program? on-error)
        (run-program on-error pattern input))
       (else
        'jaro/run-assoc-failed))))

;;
;; Path ops
;;

(define regexp/url (make-regexp "^[a-zA-Z]+:"))

(define (string-last-char str)
  (string-ref str (1- (string-length str))))

(define (path-join . paths)
  (define (joiner current-path full-path)
    (cond
     ((string-null? full-path) current-path)
     ((equal? (string-last-char full-path) #\/) (string-append full-path current-path))
     (else (string-append full-path "/" current-path))))
  (fold joiner  "" paths))

(define (path->abs path)
  (cond
   ((equal? (string-ref path 0) #\/) path)
   (else (path-join (getcwd) path))))

(define (path->uri path)
  (cond
   ((regexp-exec regexp/url path) path)
   (else (string-append "file://" (path->abs path)))))

;;
;; Formatter related
;;

(define (substring-replace str sub rep)
  "Replace all occurrences of SUB in STR with REP"
  (regexp-substitute/global #f sub str 'pre rep 'post))

(define (get-matches program pattern input)
  (let* ((matches (regexp-exec pattern input)))
    (map
     (λ (it)
       `(,(string-append "%" (number->string it))
         . ,(match:substring matches it)))
     (iota (match:count matches)))))

(define (replace-matches program pattern input)
  (if (list? pattern)
      program
      (fold
       (λ (it all)
         (substring-replace all (car it) (cdr it)))
       program
       (get-matches program pattern input))))

(define (format-program program pattern input)
  (cond
   ((list? program) (map (λ (it) (format-program it pattern input)) program))
   ((string? program)
    (->
     ;; FIXME: (regexp-exec) is called in replace-matches repeadetly, maybe optimize that
     (replace-matches program pattern input)
     (substring-replace "%f" input)
     (substring-replace "%F" (path->abs input))
     (substring-replace "%U" (path->uri input))))))

;;
;; Main
;;

(define* (assoc #:key pattern name #:allow-other-keys #:rest args)
  ;; FIXME:
  (set! jaro/assocs (append jaro/assocs `((#:pattern ,(compile-pattern pattern) ,@args))))
  (when (specified? name)
    (hashq-set! jaro/named-assocs name args)))


(define (jaro/run input)
  (let* ((candidates (filter (λ (it) (pattern-matches? (plist-get it #:pattern) input)) jaro/assocs)))
    (if (null? candidates)
        'jaro/no-matches
        (run-assoc (car candidates) (cdr candidates) input))))
