#!/usr/bin/env sh
exec guile -e main -s "$0" "$@"
!#

;; TODO: maybe use (ice-9 optargs) instead of plist implementation
;; https://www.gnu.org/software/guile/manual/html_node/Coding-With-Keywords.html

(use-modules
 (ice-9 control)
 (ice-9 regex)
 (ice-9 rdelim)
 (ice-9 popen)
 (ice-9 match)
 (ice-9 ftw)
 (ice-9 pretty-print)
 (ice-9 poe)
 (ice-9 getopt-long)
 (ice-9 receive)
 (web uri)
 (srfi srfi-1)
 (srfi srfi-2))

;;
;; State
;;

(define jaro/assocs '())
(define jaro/named-assocs (make-hash-table))
(define jaro/env #f)
(define jaro/cold-run? #t)
(define jaro/runner-method #f)
(define jaro/debug? #t)

(define jaro/emacsclient-binary "emacsclient")

;;
;; Utils
;;

(define specified? (compose not unspecified?))

(define (sh cmd)
  (let* ([error-pipe (pipe)]
         [port (with-error-to-port (cdr error-pipe)
                 (lambda ()
                   (cond
                    ((string? cmd) (open-input-pipe cmd))
                    ((list? cmd) (apply open-pipe* (cons OPEN_READ cmd))))))]
         [std-out (read-string port)])
    (close-port (cdr error-pipe))
    (values
     (close-pipe port)
     std-out
     (read-string (car error-pipe)))))

(define (sh-out cmd)
  (receive (exit-code std-out _)
      (sh cmd)
    (if (equal? exit-code 0)
        std-out
        #f)))

(define (append-to-file file-path string)
  (let ((output-port (open-file file-path "a")))
    (display string output-port)
    (newline output-port)
    (close output-port)))

;; https://github.com/alezost/guile-config/blob/master/modules/al/plists.scm
(define (plist-get plist property)
  "Return a value of PROPERTY from PLIST.
Return #f if PROPERTY does not exist."
  (match plist
    ((prop val rest ...)
     (if (eq? prop property)
         val
         (plist-get rest property)))
    (_ #f)))

;;
;; Mimetype
;;

(define (mimetype-by command)
  "Extract the mimetype from the output of the COMMAND."
  (let ((mime (string-split (sh-out command) #\newline)))
    (and mime (car mime))))

(define (mimetype-of-uri URI)
  "Get the mimetype of given URI."
  (let ((uri (string->uri URI)))
    (and
     uri
     (string-append "x-scheme-handler/" (symbol->string (uri-scheme uri))))))

(define (mimetype-of-file file)
  "Get the mimetype of FILE using `mimetype' binary."
  (let ((mimetype
         (or
          (mimetype-by `("mimetype" "--brief" "--dereference" ,file))
          (mimetype-by `("file" "--brief" "--dereference" "--mime-type" ,file)))))
    (and (not (string-null? mimetype)) mimetype)))

(define mimetype
  (pure-funcq
   (λ (path)
     "Get mimetype of given PATH."
     (or
      (mimetype-of-uri path)
      (mimetype-of-file path)))))

;;
;; Pattern
;;

(define (run-regexp pattern input mimetype)
  "Check if given PATTERN matches with INPUT or MIMETYPE."
  (or (regexp-exec pattern input)
      (and mimetype (regexp-exec pattern mimetype))))

(define (pattern-matches? pattern input)
  "Check if PATTERN matches with the INPUT."
  (cond
   ((regexp? pattern)
    (run-regexp pattern input (mimetype input)))
   ((list? pattern)
    (any identity (map (λ (it) (pattern-matches? it input)) pattern)))
   (else #f)))

(define (compile-pattern pattern)
  "Compile given PATTERN into regexp or list of regexpes."
  (cond
   ((string? pattern) (make-regexp pattern))
   ((regexp? pattern) pattern)
   ((list? pattern) (map compile-pattern pattern))))

(define (running-environments)
  (filter
   identity
   (list
    (and jaro/env (symbol->keyword jaro/env))
    (and (getenv "TMUX") #:tmux)
    (and (getenv "STY") #:screen)
    (and (or (getenv "INSIDE_EMACS") (string-contains-ci (getenv "_") "emacs")) #:emacs)
    (and (getenv "VIMRUNTIME") #:vim)
    (or (and (isatty? (current-output-port)) #:term) #:program))))

(define (assoc->env-program assoc)
  (find
   (lambda (it)
     (and-let* ([_ (keyword? it)]
                [env (symbol->string (keyword->symbol it))]
                [_ (string-prefix? "env=" env)]
                [isenv (getenv (substring env 4))])
       #t))
   assoc))

(define (assoc->runner assoc)
  "Get the running strategy for given ASSOC based on the environment."
  (or
   (and jaro/runner-method
        (plist-get assoc jaro/runner-method))
   (and-let* ([env-program (assoc->env-program assoc)])
     (plist-get assoc env-program))
   (first
    (map
     (lambda (it) (plist-get assoc it))
     (running-environments)))
   (plist-get assoc #:program)))

;;
;; Running programs
;;

;; TODO: maybe extend this, so that user can define what happens on
;; each exit code.  like #:exit=0 "this" #:exit=555 "that"
(define (map-exit-code code)
  (case code
    ((0) #t)
    (else #f)))

(define (program? it)
  "Return if IT is a runnable thing or not."
  (or (string? it)
      (procedure? it)
      (and (list? it) (not (null-list? it)))
      (and (symbol? it) (hashq-get-handle jaro/named-assocs it))))

(define (jaro/system program)
  (if jaro/cold-run?
      (let ((program-to-run (if (list? program) (string-join program " ") program)))
        (jaro/debug "(jaro/system ~a)" program-to-run)
        program-to-run)
       (map-exit-code
        (cond
         ((string? program) (system program))
         ((list? program) (apply system* program))))))

;; TODO add coldrun
(define (run-program program pattern input)
  (cond
   [(procedure? program)
    (program
     input
     (mimetype input)
     (get-matches program pattern input))]
   [(or (list? program) (string? program))
    (jaro/system (format-program program (get-matches program pattern input) input))]
   [else
    (run-program
     (assoc->runner (cdr (hashq-get-handle jaro/named-assocs program)))
     pattern
     input)]))

(define (run-alternatives input alternatives)
  (if (null? alternatives)
      'jaro/no-matches
  (run-assoc (car alternatives) (cdr alternatives) input)))

;;
;; Path ops
;;

(define regexp/url (make-regexp "^[a-zA-Z]+:"))

(define (string-last-char str)
  (string-ref str (1- (string-length str))))

(define (path-join . paths)
  (define (joiner current-path full-path)
    (cond
     ((string-null? full-path) current-path)
     ((equal? (string-last-char full-path) #\/) (string-append full-path current-path))
     (else (string-append full-path "/" current-path))))
  (fold joiner  "" paths))

(define (path->abs path)
  (cond
   ((equal? (string-ref path 0) #\/) path)
   (else (path-join (getcwd) path))))

(define (path->uri path)
  (cond
   ((regexp-exec regexp/url path) path)
   (else (string-append "file://" (path->abs path)))))

;;
;; Defaults
;;

(define home-dir
  (getenv "HOME"))

(define config-dir
  (or (getenv "XDG_CONFIG_HOME") (path-join home-dir ".config")))

(define cache-dir
  (or (getenv "XDG_CACHE_HOME") (path-join home-dir ".cache")))

(define jaro/assoc-file-path
  (path-join config-dir "associations"))

;;
;; Formatter related
;;

(define (get-matches program pattern input)
  (cond
   ((regexp? pattern)
    (let* ((matches (run-regexp pattern input (mimetype input))))
      (map
       (λ (it)
         (cons (string-append "%" (number->string it))
               (match:substring matches it)))
       (iota (match:count matches)))))
   ((list? pattern)
    (and-let* ([matched-pattern (find (lambda (it) (pattern-matches? it input)) pattern)])
      (get-matches program matched-pattern input)))))

(define (format-program program matches input)
  (cond
   ((list? program) (map (λ (it) (format-program it matches input)) program))
   ((string? program)
    (regexp-substitute/global
     #f
     "%[0-9fFU]"
     program
     'pre
     (lambda (m)
       (match (match:substring m)
         ["%f" input]
         ["%F" (path->abs input)]
         ["%U" (path->uri input)]
         [subgroup (or (assoc-ref matches subgroup) subgroup)]))
     'post))))

;;
;; INI stuff
;;

;; FIXME fix
(define (system-binary-list)
  (append-map
   (λ (path)
     (or (scandir
          path
          (λ (file)
            (let ((abspath (path-join path file)))
              (and (file-exists? abspath) (not (file-is-directory? abspath))))))
         '()))
   (string-split (getenv "PATH") #\:)))

(define (read-ini file)
  "Read an INI FILE and return a hashtable."
  (define current-group #f)
  (define ini-file (open-input-file file))
  (define ini (make-hash-table))
  (let loop ()
    (define line (read-line ini-file))
    (unless (eof-object? line)
      (set! line (string-trim-both line))
      (cond
       ((or (string-null? line)
            ;; TODO replace with contains
            (equal? (string-ref line 0) #\;)
            (equal? (string-ref line 0) #\#))
        (loop))
       ((and (equal? (string-ref line 0) #\[)
             (equal? (string-ref line (1- (string-length line))) #\]))
        (set! current-group (substring line 1 (1- (string-length line))))
        (hash-set! ini current-group (make-hash-table))
        (loop))
       (else
        (let* ((line-data (map string-trim-both (string-split line #\=)))
               (key (car line-data))
               (val (cadr line-data)))
          (hash-set! (hash-ref ini current-group (make-hash-table)) key val)
          (loop))))))
  (close-input-port ini-file)
  ini)

(define (read-boolean val)
  (string= (string-downcase val) "true"))

;; TODO read local values (tr, en, etc.)
(define (read-app-ini file)
  (let* ([ini (read-ini file)]
         [desktop-entry (hash-ref ini "Desktop Entry")]
         [name (hash-ref desktop-entry "Name")]
         [comment (hash-ref desktop-entry "Comment")])
    (list
     #:name name
     #:comment comment
     #:exec (hash-ref desktop-entry "Exec")
     #:term (read-boolean (hash-ref desktop-entry "Terminal"))
     #:display-name (format #f "~a (~a)"
                              (string-delete name #\")
                              (string-delete comment #\")))))

;; TODO dont fail if ini file is not found
(define (select-alternative-with cmd)
  (λ (input mimetype matches)
    (let* ([apps-dir "/usr/share/applications/"]
           [ini (read-ini (path-join apps-dir "mimeinfo.cache"))]
           [alternatives-str (hash-ref (hash-ref ini "MIME Cache") mimetype)]
           [alternative-apps (filter (compose not string-null?) (string-split alternatives-str #\;))]
           [programs (map (lambda (it) (read-app-ini (path-join apps-dir it))) alternative-apps)]
           [alternatives (map (λ (it) (plist-get it #:display-name)) programs)]
           [binaries (system-binary-list)]
           [binaries* (string-join binaries "\n")]
           [alternatives* (string-join alternatives "\n")]
           [entries (string-append alternatives* "\n" binaries*)]
           [out (sh-out (string-append "printf '" entries "' | " cmd))]
           [result (if out (string-trim-both out) #f)])
      (cond
       [(not result)
        (display "No matches found!")
        (newline)
        (exit 1)]
       [(string-suffix? ")" result)
        (let* ([app-exec (plist-get
                          (find (λ (it) (equal? (plist-get it #:display-name) result)) programs)
                          #:exec)]
               [exec (regexp-substitute
                      #f (string-match "(%f|%F|%u|%U)" app-exec)
                      'pre input 'post)])
          (system exec))]
       [else
        (system* result input)]))))

;;
;; User level functions
;;

(define* (assoc #:key pattern name #:allow-other-keys #:rest args)
  ;; FIXME:
  (set! jaro/assocs (append jaro/assocs `((#:pattern ,(compile-pattern pattern) ,@args))))
  (when (specified? name)
    (hashq-set! jaro/named-assocs name args)))

(define (open-with name)
  (lambda* (file #:rest r)
    (let ((opener (hashq-ref jaro/named-assocs name)))
      (cond
       (opener
        (run-assoc opener '() file))
       (else
        (display (symbol->string name))
        (display " not found in associations!")
        (newline)
        #f)))))

(define-syntax program
  (lambda (x)
    (syntax-case x ()
      ((_ body ...)
       (with-syntax ((input (datum->syntax x '$input))
                     (mimetype (datum->syntax x '$mimetype))
                     (matches (datum->syntax x '$matches))
                     ($0 (datum->syntax x '$0))
                     ($1 (datum->syntax x '$1))
                     ($2 (datum->syntax x '$2))
                     ($3 (datum->syntax x '$3))
                     ($4 (datum->syntax x '$4))
                     ($5 (datum->syntax x '$5)))
         #'(lambda (input mimetype matches)
             (let ([$0 (assoc-ref matches "%0")]
                   [$1 (assoc-ref matches "%1")]
                   [$2 (assoc-ref matches "%2")]
                   [$3 (assoc-ref matches "%3")]
                   [$4 (assoc-ref matches "%4")]
                   [$5 (assoc-ref matches "%5")])
               body ...)))))))

(define-syntax elisp
  (syntax-rules ()
    ((_ exp ...)
     (lambda (input mimetype matches)
       (jaro/system
        (list
         jaro/emacsclient-binary "--eval"
         (format-program
          (format #f "~s" (quote (progn exp ...)))
          matches
          input)))))))

;;
;; Jaro utils
;;

(define* (jaro/debug in #:rest args)
  (when jaro/debug?
    (display (apply format #f (string-append ">> [jaro] " in) args))
    (newline)))

;;
;; Main
;;

(define (run-assoc assoc alternatives input)
  (let* ([pattern (plist-get assoc #:pattern)]
         [program (assoc->runner assoc)]
         [test (plist-get assoc #:test)]
         [on-fail (plist-get assoc #:on-fail)]
         [on-success (plist-get assoc #:on-success)]
         [on-error (plist-get assoc #:on-error)]
         [continue-on-error (plist-get assoc #:continue-on-error)])
    (cond
     [(or (not test)
          (and test (run-program test pattern input)))
      (let ((success? (run-program program pattern input)))
        (jaro/debug "running result is ~a" success?)
        (cond
         ((and success? on-success)
          (run-program on-success pattern input))
         (success?
          success?)
         ((or (eq? on-error 'continue) continue-on-error)
          (run-alternatives input alternatives))
         ((eq? on-error #f)
          'jaro/non-zero-without-on-error)
         ((program? on-error)
          (run-program on-error pattern input))
         (else
          'jaro/run-assoc-failed)))]
     [(and test (eqv? on-fail 'continue))
      (run-alternatives input alternatives)]
     [(and test (program? on-fail))
      (run-program on-fail pattern input)]
     [test
      (run-alternatives input alternatives)]
     [else
      'test/success])))

(define (jaro/run input)
  (let* ((candidates
          (filter
           (λ (it) (pattern-matches? (plist-get it #:pattern) input))
           jaro/assocs)))
    (if (null? candidates)
        (begin
          (jaro/debug "failed to match anything!")
          'jaro/no-matches)
        (begin
          (jaro/debug "possible candidates are ~a" candidates)
          (run-assoc (car candidates) (cdr candidates) input)))))

(define (main args)
  (let* ((option-spec '((mime-type (single-char #\t) (value #f))
                        (cold-run (single-char #\c) (value #f))
                        (assoc-file (single-char #\f) (value #t))
                        (method (single-char #\m) (value #t))
                        (no-stdin (single-char #\N) (value #f))
                        (help (single-char #\h) (value #f))))
         (options (getopt-long args option-spec))
         (cold-run? (option-ref options 'cold-run #f))
         (mime? (option-ref options 'mime-type #f))
         (method? (option-ref options 'method #f))
         (no-stdin? (option-ref options 'no-stdin #f))
         (assoc-file? (option-ref options 'assoc-file jaro/assoc-file-path))
         (help? (option-ref options 'help #f))
         (url? (option-ref options '() #f))
         (url (cond
               ((pair? url?) (car url?))
               (no-stdin? #f)
               (else (read-line)))))
    (set! jaro/env (option-ref options 'force-env #f))
    (cond
     (mime?
      (display (mimetype url))
      (newline))
     (help?
      (display "No help yet :( Please read the README.md file at github."))
     ((not url)
      (display "No URI found.")
      (newline)
      (exit 1))
     (else
      (set! jaro/cold-run? cold-run?)
      (set! jaro/runner-method (and method? (symbol->keyword (string->symbol method?))))
      (load assoc-file?)
      (jaro/run url)))))
